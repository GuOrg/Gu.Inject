namespace Gu.Inject.Analyzers.CodeFixes
{
    using System.Collections.Immutable;
    using System.Composition;
    using System.Linq;
    using System.Threading.Tasks;
    using Gu.Roslyn.AnalyzerExtensions;
    using Gu.Roslyn.CodeFixExtensions;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CodeActions;
    using Microsoft.CodeAnalysis.CodeFixes;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.Editing;

    [ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(AutoBindFix))]
    [Shared]
    public class AutoBindFix : CodeFixProvider
    {
        private const string AutoBind = nameof(AutoBind);
        private const string ContainerExtensions = nameof(ContainerExtensions);

        public override ImmutableArray<string> FixableDiagnosticIds { get; } = ImmutableArray.Create(
            GuInj001AddAutoBind.DiagnosticId);

        public static MethodDeclarationSyntax ExtensionMethod(SyntaxGenerator g, INamedTypeSymbol containerType, SemanticModel semanticModel, ObjectCreationExpressionSyntax containerCreation)
        {
            return ((MethodDeclarationSyntax)g.MethodDeclaration(
                accessibility: Accessibility.Public,
                modifiers: DeclarationModifiers.Static,
                returnType: g.TypeExpression(containerType),
                name: AutoBind,
                parameters: new[]
                {
                                    SyntaxFactory.Parameter(
                                        default,
                                        SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.ThisKeyword)),
                                        (TypeSyntax)g.TypeExpression(containerType),
                                        SyntaxFactory.Identifier("container"),
                                        default),
                },
                statements: new[]
                {
                                    g.ReturnStatement(Bind((IdentifierNameSyntax)g.IdentifierName("container"), containerType.TypeArguments[0])),
                }))
            .WithDocumentationText(
                StringBuilderPool.Borrow()
                    .AppendLine("/// <summary>")
                    .AppendLine($"/// Adds generated bindings for the graph where <see cref=\"{containerType.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}\"/> is root.")
                    .AppendLine("/// This method is generated by Gu.Inject.Analyzers.")
                    .AppendLine("/// </summary>")
                    .AppendLine($"/// <param name=\"container\">The <see cref=\"Gu.Inject.Container{{{containerType.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}}}\"/>.</param>")
                    .Return())
            .WithSimplifiedNames();

            ExpressionSyntax Bind(ExpressionSyntax e, ITypeSymbol type)
            {
                if (type is INamedTypeSymbol namedType)
                {
                    if (namedType.Constructors.TrySingle(x => !x.IsStatic, out var ctor))
                    {
                        if (!semanticModel.IsAccessible(containerCreation.SpanStart, ctor) ||
                            ctor.Parameters.Any(x => x.RefKind != RefKind.None ||
                                                     x.HasExplicitDefaultValue))
                        {
                            return e;
                        }

                        e = (InvocationExpressionSyntax)g.InvocationExpression(
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                e.WithTrailingTrivia(SyntaxFactory.ElasticEndOfLine("\n")),
                                SyntaxFactory.Token(SyntaxKind.DotToken).WithLeadingTrivia(SyntaxFactory.ElasticWhitespace("            ")),
                                SyntaxFactory.IdentifierName("Bind")),
                            Lambda());

                        foreach (var parameter in ctor.Parameters)
                        {
                            e = (InvocationExpressionSyntax)Bind(e, parameter.Type);
                        }

                        return e;

                        SyntaxNode Lambda()
                        {
                            if (ctor.Parameters.Length == 0)
                            {
                                return g.ValueReturningLambdaExpression(
                                    new[] { g.LambdaParameter("_") },
                                    g.ObjectCreationExpression(type));
                            }

                            return g.ValueReturningLambdaExpression(
                                new[] { g.LambdaParameter("x") },
                                g.ObjectCreationExpression(
                                    type,
                                    ctor.Parameters.Select(x =>
                                        g.InvocationExpression(
                                            g.MemberAccessExpression(
                                                SyntaxFactory.IdentifierName("x"),
                                                g.GenericName("Get", x.Type))))));
                        }
                    }
                }

                return e;
            }
        }

        public static CompilationUnitSyntax ExtensionClass(SyntaxGenerator g, NameSyntax namespaceName, INamedTypeSymbol containerType, SemanticModel semanticModel, ObjectCreationExpressionSyntax containerCreation)
        {
            return (CompilationUnitSyntax)g.CompilationUnit(
                SyntaxFactory.NamespaceDeclaration(
                    namespaceKeyword: SyntaxFactory.Token(default, SyntaxKind.NamespaceKeyword, ElasticWhitespace(" ")),
                    name: namespaceName,
                    openBraceToken: SyntaxFactory.Token(default, SyntaxKind.OpenBraceToken, ElasticEndOfLine()),
                    externs: default,
                    usings: default,
                    members: SyntaxFactory.SingletonList<MemberDeclarationSyntax>(ClassDeclaration()),
                    closeBraceToken: SyntaxFactory.Token(SyntaxKind.CloseBraceToken),
                    semicolonToken: SyntaxFactory.Token(SyntaxKind.None)));

            ClassDeclarationSyntax ClassDeclaration()
            {
                return SyntaxFactory.ClassDeclaration(
                    attributeLists: default,
                    modifiers: SyntaxFactory.TokenList(
                        SyntaxFactory.Token(ElasticWhitespace("    "), SyntaxKind.PublicKeyword, default),
                        SyntaxFactory.Token(SyntaxKind.StaticKeyword)),
                    keyword: SyntaxFactory.Token(SyntaxKind.ClassKeyword),
                    identifier: SyntaxFactory.Identifier(default, SyntaxKind.IdentifierToken, ContainerExtensions, ContainerExtensions, default),
                    typeParameterList: default,
                    baseList: default,
                    constraintClauses: default,
                    openBraceToken: SyntaxFactory.Token(SyntaxKind.OpenBraceToken),
                    members: default,
                    closeBraceToken: SyntaxFactory.Token(SyntaxKind.CloseBraceToken),
                    semicolonToken: SyntaxFactory.Token(SyntaxKind.None));
            }
            //return (CompilationUnitSyntax)g.CompilationUnit(
            //                                    g.NamespaceDeclaration(
            //                                        namespaceName,
            //                                        ((ClassDeclarationSyntax)g.ClassDeclaration(
            //                                            accessibility: Accessibility.Public,
            //                                            modifiers: DeclarationModifiers.Static,
            //                                            name: ContainerExtensions,
            //                                            members: new[] { ExtensionMethod(g, containerType, semanticModel, containerCreation) }))
            //                                        .WithDocumentationText(
            //                                            StringBuilderPool.Borrow()
            //                                                             //// .AppendLine("// <auto-generated/>")
            //                                                             .AppendLine("/// <summary>")
            //                                                             .AppendLine("/// Extension methods for <see cref=\"Gu.Inject.Container{T}\" />.")
            //                                                             .AppendLine("/// This file is generated by Gu.Inject.Analyzers.")
            //                                                             .AppendLine("/// </summary>")
            //                                                             .Return())))
            //                                .WithSimplifiedNames();
        }

        public override FixAllProvider GetFixAllProvider() => null;

        public override async Task RegisterCodeFixesAsync(CodeFixContext context)
        {
            var syntaxRoot = await context.Document.GetSyntaxRootAsync(context.CancellationToken)
                                          .ConfigureAwait(false);
            var semanticModel = await context.Document.GetSemanticModelAsync(context.CancellationToken)
                                             .ConfigureAwait(false);
            if (syntaxRoot is CompilationUnitSyntax compilationUnit)
            {
                foreach (var diagnostic in context.Diagnostics)
                {
                    if (syntaxRoot.TryFindNode(diagnostic, out ObjectCreationExpressionSyntax containerCreation) &&
                        semanticModel.TryGetType(containerCreation, context.CancellationToken, out var temp) &&
                        temp is INamedTypeSymbol containerType)
                    {
                        if (TryFindAutoBind(semanticModel, containerCreation, containerType, out var containerExtensions, out var autoBind))
                        {
                            if (autoBind != null)
                            {
                                context.RegisterCodeFix(
                                    CodeAction.Create(
                                        $"Call {AutoBind}()",
                                        _ => Task.FromResult(
                                            context.Document.WithSyntaxRoot(
                                                WithCallToAutoBind(autoBind.Name).AddUsing(autoBind.ContainingType, semanticModel))),
                                        nameof(AutoBindFix)),
                                    diagnostic);
                            }
                            else
                            {
                                foreach (var reference in containerExtensions.DeclaringSyntaxReferences)
                                {
                                    var declaration = (ClassDeclarationSyntax)reference.GetSyntax(context.CancellationToken);
                                    context.RegisterCodeFix(
                                        CodeAction.Create(
                                            $"Generate and call {AutoBind}()",
                                            cancellationToken =>
                                            {
                                                var sln = context.Document.Project.Solution;
                                                var extDoc = sln.GetDocument(declaration.SyntaxTree);
                                                return Task.FromResult(
                                                    sln.WithDocumentSyntaxRoot(
                                                           context.Document.Id,
                                                           WithCallToAutoBind(AutoBind).AddUsing(containerExtensions, semanticModel))
                                                       .WithDocumentSyntaxRoot(
                                                           extDoc.Id,
                                                           declaration.SyntaxTree
                                                                      .GetRoot(cancellationToken)
                                                                      .ReplaceNode(
                                                                          declaration,
                                                                          declaration.AddMembers(
                                                                              ExtensionMethod(
                                                                                  SyntaxGenerator.GetGenerator(context.Document.Project.GetDocument(declaration.SyntaxTree)),
                                                                                  containerType,
                                                                                  semanticModel,
                                                                                  containerCreation)))));
                                            },
                                            nameof(AutoBindFix)),
                                        diagnostic);
                                }
                            }
                        }
                        else if (containerCreation.TryFirstAncestor(out NamespaceDeclarationSyntax namespaceDeclaration))
                        {
                            context.RegisterCodeFix(
                                CodeAction.Create(
                                    $"Generate and call {AutoBind}()",
                                    cancellationToken =>
                                    {
                                        var sln = context.Document.Project.Solution;
                                        return Task.FromResult(
                                            sln.WithDocumentSyntaxRoot(
                                                    context.Document.Id,
                                                    WithCallToAutoBind(AutoBind))
                                                .AddDocument(
                                                    DocumentId.CreateNewId(context.Document.Project.Id),
                                                    "Extensions.generated.cs",
                                                    ExtensionClass(
                                                        SyntaxGenerator.GetGenerator(context.Document.Project),
                                                        namespaceDeclaration.Name,
                                                        containerType,
                                                        semanticModel,
                                                        containerCreation),
                                                    context.Document.Folders));
                                    },
                                    nameof(AutoBindFix)),
                                diagnostic);
                        }

                        CompilationUnitSyntax WithCallToAutoBind(string name)
                        {
                            return compilationUnit.ReplaceNode(
                                                      containerCreation,
                                                      SyntaxFactory.InvocationExpression(
                                                          SyntaxFactory.MemberAccessExpression(
                                                              SyntaxKind.SimpleMemberAccessExpression,
                                                              containerCreation,
                                                              SyntaxFactory
                                                                  .IdentifierName(name))));
                        }
                    }
                }
            }
        }

        private static bool TryFindAutoBind(SemanticModel semanticModel, ObjectCreationExpressionSyntax objectCreation, ITypeSymbol containerType, out INamedTypeSymbol containerExtensions, out IMethodSymbol autoBind)
        {
            foreach (var candidate in semanticModel.LookupSymbols(objectCreation.SpanStart, containerType, AutoBind, includeReducedExtensionMethods: true))
            {
                if (candidate is IMethodSymbol method &&
                    method.IsExtensionMethod &&
                    method.Parameters.Length == 0)
                {
                    containerExtensions = method.ContainingType;
                    autoBind = method;
                    return true;
                }
            }

            foreach (var candidate in semanticModel.LookupNamespacesAndTypes(objectCreation.SpanStart, name: ContainerExtensions))
            {
                if (candidate is INamedTypeSymbol type &&
                    type.IsStatic)
                {
                    autoBind = null;
                    containerExtensions = type;
                    return true;
                }
            }

            foreach (var candidate in semanticModel.LookupNamespacesAndTypes(objectCreation.SpanStart))
            {
                if (candidate is INamespaceSymbol ns)
                {
                    if (TryFindRecursive(ns, objectCreation, containerType, semanticModel, out containerExtensions, out autoBind))
                    {
                        return true;
                    }
                }
            }

            containerExtensions = null;
            autoBind = null;
            return false;
        }

        private static bool TryFindRecursive(INamespaceSymbol ns, ObjectCreationExpressionSyntax objectCreation, ITypeSymbol containerType, SemanticModel semanticModel, out INamedTypeSymbol containerExtensions, out IMethodSymbol autoBind)
        {
            foreach (var candidate in semanticModel.LookupNamespacesAndTypes(objectCreation.SpanStart, ns))
            {
                switch (candidate)
                {
                    case INamespaceSymbol nested when TryFindRecursive(nested, objectCreation, containerType, semanticModel, out containerExtensions, out autoBind):
                        return true;
                    case INamedTypeSymbol type when type.IsStatic && type.Name == ContainerExtensions:
                        containerExtensions = type;
                        _ = type.TryFindFirstMethod(
                            AutoBind,
                            x => x.IsExtensionMethod &&
                                 x.Parameters.TrySingle(out var parameter) &&
                                 Equals(parameter.Type, containerType),
                            out autoBind);
                        return true;
                }
            }

            containerExtensions = null;
            autoBind = null;
            return false;
        }

        private static SyntaxTriviaList ElasticWhitespace(string whitespace) => SyntaxFactory.TriviaList(SyntaxFactory.ElasticWhitespace(whitespace));

        private static SyntaxTriviaList ElasticEndOfLine() => SyntaxFactory.TriviaList(SyntaxFactory.ElasticEndOfLine("\n"));
    }
}
